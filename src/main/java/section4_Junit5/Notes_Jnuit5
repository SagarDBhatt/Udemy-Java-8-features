********************************************************
                        ONSJHJSA
********************************************************

Junit 5 architecture:

==> Junit 5 has two mandatory packages to run Junits.
1. Platform: This is base to run different tests i.e. Test engine
2. API packages: There are 3 types.
    i. Jupiter: API to run test cases.
    ii. Vintage: API to support older versions of Jnit.
    iii. Extention Library: Dev create own extention using 3rd party library to create API.

==> Maven Depenedency: To Run Jupiter, Dev require two depenedencies.
    1. junit-jupiter-engine
    2. junit-jupiter-api (platform - surefire provider)

            <dependency>
                <groupId>org.junit.platform</groupId>
                <artifactId>junit-platform-surefire-provider</artifactId>
                <version>1.0.1</version>
            </dependency>
            <dependency>
                <groupId>org.junit.jupiter</groupId>
                <artifactId>junit-jupiter-engine</artifactId>
                <version>5.0.1</version>
            </dependency>

==> Inside the property, dev define a variable for jupiter version.
    The value of this tag <junit.jupiter.version> is used inside the dependency.

     <properties>
            <!-- This is the variable where we define the version for J unit.
            This variable should be use within dependency block. See Junit-jupiter-engine dependency  -->

            <junit.jupiter.version>5.4.0</junit.jupiter.version>
        </properties>

==> As seen below, Sysntax to use variable is "${ }".

     <dependency>
               <groupId>org.junit.jupiter</groupId>
               <artifactId>junit-jupiter-engine</artifactId>
               <version>${junit.jupiter.version}</version>
               <scope>test</scope>
     </dependency>
=============================================================================================

         HOW TO CREATE JUNIT TEST CASE:

-> Simple method is to create a "Test class" and define method. In Maven projects path should be in "src/test/java".
-> Use IDE support: Right click in class -> Generate -> Test.
        -> This will create a separate class with test method in Java.

==> Below is the auto generated Test class with name: MathUtilsTest.java

        class MathUtilsTest {

            @Test
            void add() {
                System.out.println("This test run");
            }
        }

--> @Test : 1. Tell IDE this is Test method. As the test class doesn't have Main method,
            IDE start execution from @Test annotation.
            2. Tell Junit test engine this method needs to test.

===================================================================================================================

**** CREATE TEST METHOD AND RUN:

1. Generate Test method (Alt + Insert -> Test...), Select class MathUtils and the method which I want to Test. In my case it is Add().
2. This will automatically create an class "MathUtilTest" in "Src/Test/Java" package with method annotated as @Test.
    class MathUtilsTest {
        @Test
        void add() {
        }
    }

3. Execution of this class is started from @Test annotation. All the methods with @Test annotation will be executed.
4. Now, basic concept to test any method is to verify if for specific value, will this method generate expected output.

5. Basic flow to test Add() is to pass two values and store the result in variable. validate the value of the variable is same as expected.

    @Test
    void add() {
       MathUtils mathUtils = new MathUtils();
       int actual = mathUtils.add(1,1);
       int expected = 2;

       if (actual == expected)
           System.out.println("This test passed!!");
    }

6. To print "Test passed" for all the Tests should be very difficult for a huge code base.
    Another way is to use "assertEquals(expected,actual)".

7. I can put the message in "assertEquals" method as a third argument. This will be helpful for a large code base to identify
    which method fails.

    assertEquals(expected,actual,"The add method should add two numbers");

===================================================================================================================
===================================================================================================================

**** TEST DRIVER DEVELOPMENT:

1. In TDD approach, I need to built the test method first and then I need to start developing my actual code.
2. I need to develop the code till the test successfully passed.
3. Advantage of this approach is when I get an user case, I develop the test first. This time all the test fails as I have not developed
    any code. Now, I need to start developing my code till my test case pass.

4. I need to test a method which calculate the area of circle. First let me develop the test method "testCalcCircleArea".

        @Test
        void testCalcCircleArea(){
            MathUtils utils = new MathUtils();

            double expectedArea = 314.0;
            double actual = utils.calcCircleArea(10);
            assertEquals(expectedArea,actual,"The area of the circle should match");
        }

5. I created the signature of the method but did not build any code inside.

        public double calcCircleArea(double radius){
            return 0;
        }

6. Now, the test case fails as the return value is 0. I need to keep building/editing the code until the test case passes.

        public double calcCircleArea(double radius){
            return 3.14 * radius * radius;
        }

7. Above code runs fine and my test method passed successfully.

===================================================================================================================
===================================================================================================================

**** TEST IF METHOD THROWS VALID EXCEPTION:

1. Developer needs to verify that the method is throwing the valid exception.
2. I created a method divide(int a, int b). This method divide a by b. If the b = 0 then method should throw airthematic exception.

        public double divide(int a, int b){
            return a/b;
        }

3. Now, create a test method and check if the method is throwing valid exception or not. "assertThrows" is a method to check if the thrown exception
    is same as expected exception.

        @Test
        void testDivide(){
            MathUtils utils = new MathUtils();
            assertThrows(ArithmeticException.class, () -> utils.divide(1,0),"Divide by zero");
        }

4. assertThrow method has 2 args. first one need to specify the expected exception. In our case "ArithematicException.class".
    second arg required executables and this can be provided using lambda expression.

        () -> utils.divide(1,0);

===================================================================================================================
===================================================================================================================

**** TEST LIFECYCLE ANNOTATIONS:
1. There are 4 annotations which Jnuit 5 framework provides along with @Test annotation.

    i. @BeforeAll : The method annoated with @BeforeAll executed at the beginning of the execution starts. This is the first method executed
                    before any other methods starts.

    ii. @BeforeEach : The method annotated with @BeforeEach annotation executes before each @Test method execution.

    iii. @AfterEach : The method annotated with @AfterEach annotation executes after each @Test method execution. [if there are 5 @Test method then
                        @AfterEach method executed 5 times after each @Test method executed. ]

    iv. @AfterAll: The method executed just one time after all the @Test methods executed.

==> Use of these annotations:

1. As I can see from the @Test method, I need to create an object of "MathUtils class" for each @Test method. This is a repetitive code
    which is not memory efficient.
2. Solution is, I can initialize MathUtil class object in a method annotated with @BeforeEach annotation. This will provide new object to
    each @Test method.
For Eg:

    MathUtils utils;

        @BeforeEach
        void init(){
            utils = new MathUtils();
        }

        @Test
        void add() {
           //MathUtils mathUtils = new MathUtils();
           int actual = utils.add(1,1);
           int expected = 2;
          assertEquals(expected,actual,"The add method should add two numbers");
        }